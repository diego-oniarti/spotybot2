require('dotenv').config();
const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');
const Discord = require('@discordjs/voice');
const Comando = require('../js/comando');
const { Colori } = require('../js/colori');
const fs = require('node:fs');
const path = require('node:path');
const fetch = require('node-fetch');
const { servers } = require('../shared');
const { Server, Modes } = require('../js/server');
const cliProgress = require('cli-progress');
const querystring = require('node:querystring');
const requisiti = require('../js/requisiti');
const EventEmitter = require('node:events');
const ytdl = require('ytdl-core');

const youtube_key = process.env.YOUTUBE_KEY;
const DB_PATH = process.env.DB_PATH;
let spotifyToken;

function bar_style(nome) {
    if (nome) nome+=' ';
    else nome=''
    return {
        format: `${nome}|{bar}| {percentage}% | DURATION: {duration} | ETA: {eta}s | {value}/{total}`,
    }
}

// refresha il token di spotify (scade dopo un'ora) che serve per ogni chiamata alle API di spotify
const get_bot_token = async() => {
    const params = new URLSearchParams();
    params.append('grant_type', 'client_credentials');
    fetch('https://accounts.spotify.com/api/token', {
        method: 'POST',
        headers: {
            'Authorization': 'Basic ' + (new Buffer.from(process.env.SPOTIFY_CLIENT_ID + ':' + process.env.SPOTIFY_CLIENT_SECRET).toString('base64'))
        },
        body: params,
    })
    .then(res=>res.json())
    .then(data=>{
        spotifyToken = data.access_token;
        console.log(`Got new token: ${spotifyToken}`)
    });
}
get_bot_token();


const getSpotifyToken = async(userID)=>{
    if (!userID) return spotifyToken;

    const DB = JSON.parse(fs.readFileSync(DB_PATH));
    if (DB.users[userID]?.access_token) {
        return DB.users[userID].access_token;
    } else {
        return spotifyToken;
    }
}

async function refresh_spotify_token(userID) {
    console.log(`refreshing for ${userID}`);
    if (!userID) return await get_bot_token();
    let DB = JSON.parse(fs.readFileSync(DB_PATH));
    if (DB.users[userID]?.refresh_token) {
        const params = new URLSearchParams();
        params.append('grant_type', 'refresh_token');
        params.append('refresh_token', DB.users[userID].refresh_token);

        const res = await fetch('https://accounts.spotify.com/api/token', {
            method: 'POST',
            headers: {
                'Authorization': 'Basic ' + (new Buffer.from(process.env.SPOTIFY_CLIENT_ID + ':' + process.env.SPOTIFY_CLIENT_SECRET).toString('base64')),
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: params,
        });
        const data = await res.json();
        DB.users[userID].access_token = data.access_token;
        if (data.refresh_token) DB.users[userID].refresh_token = data.refresh_token;
        fs.writeFileSync(DB_PATH, JSON.stringify(DB));
        return data.access_token;
    }else{
        console.log("from bot")
        return await get_bot_token();
    }       
}








const comando = async (song,position, member, channel)=>{
    const sameVCError = requisiti.sameVoiceChannel(member);
    if (sameVCError)
        return sameVCError;

    const guild = member.guild;

    if (!servers.has(guild.id))
        servers.set(guild.id, new Server(guild));
    const server = servers.get(guild.id);

    let titolo;
    emitter.on('collectionTitle', (collectionTitle)=>{
        titolo = collectionTitle;
    })

    const posizione = ((!position || position==-1) && position!=0)? server.queue.length : Math.min(Math.max(position,0), server.queue.length);
    // cerca la canzone (o le canzoni) e ritorna un messaggio d'errore se non si trova nulla
    try {
        var canzoni = await accodaCanzoni(song, server,posizione, emitter, member.user.id);
    }catch(error){
        let errorMsg;
        switch (error){
            case errors.YouTubeVideoNotFound:
                errorMsg = "The link you've provided doesn't seem to bring anywhere :o";
                break;
            case errors.YouTubeKeyExpired:
                errorMsg = 'We ran out of youtube quotas Â¯\_(:P)_/Â¯';
                break;
            case errors.YouTubePlaylistNotFound:
                errorMsg = "The link you've provided doesn't seem to bring anywhere :o"
                break;
            case errors.SpotifyIdNotFound:
                errorMsg = "The link you've provided doesn't seem to bring anywhere :o";
                break;
            case errors.InvalidSpotifyId:
                errorMsg = "The link you've provided seems to be malformed";
                break;
            case errors.YouTubeSearchNotFound:
                errorMsg = "We couldn't find your song";
                break;
            default:
                throw error;
        }
        if (!errorMsg)
            throw error;
        return {
            embeds: [
                new EmbedBuilder()
                .setTitle('Error!')
                .setDescription(errorMsg)
                .setColor(Colori.error)
            ]
        }
    }

    if (canzoni.length == 1)
        return {
            embeds: [
                new EmbedBuilder()
                .setTitle(`Queued at position ${posizione+1}`)
                .setDescription(`__[${canzoni[0].titolo}](${canzoni[0].link})__`)
                .setColor(Colori.default)
            ]
        };
    else
        return {
            embeds: [
                new EmbedBuilder()
                .setTitle(`Queued ${canzoni.length} songs from position ${posizione+1}`)
                .setDescription(`__[${titolo||song}](${song})__`)
                .setColor(Colori.default)
            ]
        };
}

module.exports = {
    comando: new Comando({
        data: new SlashCommandBuilder()
            .setName('play')
            .setDescription('Plays a song or adds it to the queue')
            .setDescriptionLocalizations({
                it: "Riproduce una canzone o la aggiunge alla coda"
            })
            .addStringOption(option=>
                option
                .setName("song")
                .setNameLocalizations({
                    it: "canzone"
                })
                .setDescription("YouTube link / Spotify link / YouTube query")
                .setDescriptionLocalizations({
                    it: "link di YouTube / link di Spotify / ricerca su YouTube"
                })
                .setRequired(true)
            )
            .addIntegerOption(option=>
                option
                .setName("position")
                .setNameLocalizations({
                    it: "posizione"
                })
                .setDescription("Position in the queue where to add the song")
                .setDescriptionLocalizations({
                    it: "Posizione in coda dove inserire la canzone"
                })
                .setMinValue(1)
                .setRequired(false)
            ),
        execute: async (interaction) => {
            const song = interaction.options.getString("song").trim();
            const position = interaction.options.getInteger("position")-1;

            await interaction.deferReply({ephemeral:false});

            const emitter = new EventEmitter();
            emitter.on('msg', async (msg)=>{
                await interaction.editReply(msg);
                emitter.emit('hasSent');
            });
            const response = await comando(song, position, interaction.member,interaction.channel, emitter);
            return await interaction.editReply(response);
        },


        aliases: ['play', 'p'],
        executeMsg: async (message,args)=>{
            const canzone = args.join(' ');

            if (!canzone)
                return message.channel.send({embeds:[new EmbedBuilder().setTitle('Error!').setDescription("No song specified.\nUse the `help` command to know more").setColor(Colori.error)]});

            const messaggio = await message.channel.send({
                embeds: [
                    new EmbedBuilder()
                    .setTitle('Looking for songs')
                    .setColor(Colori.default)
                ]
            });
            const emitter = new EventEmitter();
            emitter.on('msg', async (msg)=>{
                await messaggio.edit(msg);
                emitter.emit('hasSent');
            });
            const response = await comando(canzone, undefined, message.member,message.channel, emitter);
            
            return await messaggio.edit(response);
        },

        example: '`-play` `song` `[postition]`',
        description: 'Plays a song or adds it to the queue.',
        parameters: '`song`: the title or the link of the song/playlist you want to be played (supports both YouTube and Spotify)\n`[position]`: The position in the queue where to insert the song. If not specified, the song will be inserted at the end of the queue'
    }),
    fineCanzone: fineCanzone,
    suona: suona
}
